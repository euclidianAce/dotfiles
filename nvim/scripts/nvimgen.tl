
local fh = assert(io.open(os.getenv"DOTFILE_DIR" .. "/nvim/teal/euclidian/lib/nvim/_autogenerated.tl", "w"))
local function write(...: string)
	fh:write(...)
	fh:write("\n")
end

local record Func
	method: boolean
	name: string
	parameters: {{string}}
	return_type: string
	since: integer
	deprecated_since: integer
end
local record Type
	id: integer
	prefix: string
end
local record Info
	error_types: {string:{string:integer}}
	functions: {Func}
	types: {string:Type}
	ui_options: {string}
	record Version
		api_compatible: integer
		api_level: integer
		api_prerelease: boolean
		major: integer
		minor: integer
		patch: integer
	end
	version: Version
end

local	record OptInfo
	name: string
	shortname: string
	type: string
	scope: string
end

local api_info = vim.fn.api_info() as Info

local pre <const> = [[
local record MapOpts
	nowait: boolean
	silent: boolean
	script: boolean
	expr: boolean
	unique: boolean
	noremap: boolean
end]]

local typeMap <const>: {string:string} = setmetatable({
	["String"] = "string",
	["Number"] = "number",
	["Float"] = "number",
	["Integer"] = "integer",
	["Boolean"] = "boolean",
	["Buffer"] = "integer",
	["Window"] = "integer",
	["Tabpage"] = "integer",
	["Dictionary"] = "{string:any}",
	["Array"] = "{any}",
}, {
	__index = function(): string
		return "any"
	end
})

local function getTypeName(name: string): string
	local tname: string
	if name:match("ArrayOf") then
		local arrayType = name:gsub("ArrayOf%((.*)%)", "%1")
		if arrayType:find(",") then
			local elementName, _size = arrayType:match("(%S+)%s*,%s*(%d+)")
			local size = tonumber(_size) as integer
			elementName = typeMap[elementName]

			local tupleStr = {}
			for _ = 1, size do
				table.insert(tupleStr, elementName)
			end
			tname = "{" .. table.concat(tupleStr, ",") .. "}"
		else
			tname = "{" .. typeMap[arrayType] .. "}"
		end
	else
		tname = typeMap[name]
	end
	return tname -- .. "--[[" .. name .. "]]"
end

local ins <const> = table.insert

local enum NamespaceName
	"Buffer"
	"Window"
	"Tab"
	"Nvim"
end

local record Namespace
	entries: {string}
	exclude: {string:boolean}
end

local namespaces: {NamespaceName:Namespace} = {
	["Buffer"] = {
		exclude = {
			getOption = true,
			setOption = true,
			call = true,
			setKeymap = true,
		},
		entries = {
			"call: function(Buffer, function)",

			"getOption: function(Buffer, StringOpt): string",
			"getOption: function(Buffer, BooleanOpt): boolean",
			"getOption: function(Buffer, IntegerOpt): integer",
			"getOption: function(Buffer, string): number | boolean | string",

			"setOption: function(Buffer, StringOpt, string)",
			"setOption: function(Buffer, BooleanOpt, boolean)",
			"setOption: function(Buffer, IntegerOpt, integer)",
			"setOption: function(Buffer, string, integer | boolean | string)",

			"setKeymap: function(Buffer, vim.Mode, string, string | function, MapOpts)",
		},
	},
	["Window"] = {
		exclude = {
			getOption = true,
			setOption = true,
			setConfig = true,
			getConfig = true,
		},
		entries = {
			[[record Config
		enum Anchor
			"NW" "NE" "SW" "SE"
		end
		enum Style
			"minimal"
		end
		enum Relativity
			"editor" "win" "cursor"
		end
		enum PredefinedBorder
			"none"
			"single"
			"double"
			"shadow"
		end
		type Border = PredefinedBorder | { string | { string, string } }
	
		win: Id
		relative: Relativity
		anchor: Anchor
		row: integer
		col: integer
		width: integer
		height: integer
		bufpos: integer
		focusable: boolean
		external: boolean
		style: Style
		border: Border
	end]],
			"getConfig: function(Window): Config",
			"setConfig: function(Window, Config)",

			"getOption: function(Window, StringOpt): string",
			"getOption: function(Window, BooleanOpt): boolean",
			"getOption: function(Window, IntegerOpt): integer",
			"getOption: function(Window, string): integer | boolean | string",

			"setOption: function(Window, StringOpt, string)",
			"setOption: function(Window, BooleanOpt, boolean)",
			"setOption: function(Window, IntegerOpt, integer)",
			"setOption: function(Window, string, integer | boolean | string)",
		},
	},
	["Tab"] = {
		exclude = {},
		entries = {},
	},
	["Nvim"] = {
		exclude = {},
		entries = {},
	},
}

local function camelCase(s: string): string
	return (s:gsub("%_(%w)", string.upper))
end

local function processDef(f: Func)
	if f.deprecated_since then return end
	local namespace: NamespaceName = "Nvim"
	local name: string
	if f.name:match("^nvim_buf_") then
		namespace = "Buffer"
		name = f.name:sub(10, -1)
	elseif f.name:match("^nvim_win_") then
		namespace = "Window"
		name = f.name:sub(10, -1)
	elseif f.name:match("^nvim_tabpage_") then
		namespace = "Tab"
		name = f.name:sub(14, -1)
	else
		name = f.name:sub(6, -1)
	end
	name = camelCase(name)
	local ns <const> = namespaces[namespace]
	if not ns.exclude[name] then
		local args <const>: {string} = {}
		for _, param in ipairs(f.parameters) do
			ins(args, getTypeName(param[1]))
		end
		if namespace ~= "Nvim" then
			args[1] = namespace
		end
		local ret <const> = f.return_type and f.return_type ~= "void"
			and getTypeName(f.return_type)
			or nil

		ins(ns.entries, name .. ": function(" .. table.concat(args, ", ") .. ")" .. (ret and ": " .. ret or ""))
	end
end

for _, f in ipairs(api_info.functions) do
	processDef(f)
end

local opts = vim.api.nvim_get_all_options_info() as {string:OptInfo}
opts[""] = nil

local wo: {string:{string}} = {
	["string"] = {},
	["boolean"] = {},
	["integer"] = {},
}

local bo: {string:{string}} = {
	["string"] = {},
	["boolean"] = {},
	["integer"] = {},
}

for _, opt in pairs(opts) do
	local tab: {string:{string}}
	if opt.scope == "win" then
		tab = wo
	elseif opt.scope == "buf" then
		tab = bo
	end
	if opt.type == "number" then opt.type = "integer" end
	if tab then
		table.insert(tab[opt.type], opt.name)
	end
end

local function addOpts(ns: Namespace, o: {string:{string}})
	for t, vals in pairs(o) do
		local out = {}
		for _, entry in ipairs(vals) do
			ins(out, string.format("\t%q", entry))
		end
		table.sort(out)
		ins(out, "end")
		ins(out, 1, "enum " .. t:sub(1, 1):upper() .. t:sub(2) .. "Opt")
		table.insert(ns.entries, table.concat(out, "\n\t"))
	end
end
addOpts(namespaces["Window"], wo)
addOpts(namespaces["Buffer"], bo)

local function processNs(ns: NamespaceName)
	write("local record " .. ns)
	write("\ttype Id = integer")
	write("\tid: Id")
	for _, func in ipairs(namespaces[ns].entries) do
		write("\t", func)
	end
	write(("\tmetamethod __call: function(%s, integer): %s"):format(ns, ns))
	write("\tmetamethod __eq: function(any, any): boolean")
	write("end")
end

write(pre)
processNs("Buffer")
processNs("Window")
processNs("Tab")

write[[
return {
	Buffer = Buffer,
	Window = Window,
	Tab = Tab,
	MapOpts = MapOpts,
}]]

fh:close()
