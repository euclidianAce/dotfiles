local a = vim.api

local UI = {}















local auto = require("euclidian.lib.nvim._autogenerated")

local function unCamel(s)
   return (s:gsub("[A-Z]", function(m)
      return "_" .. m:lower()
   end))
end
local function genMetatable(t, prefix)
   local cache = setmetatable({}, { __mode = "kv" })
   local api = vim.api
   local index = setmetatable({}, {
      __index = function(self, key)
         local fn = api["nvim_" .. prefix .. "_" .. unCamel(key)]
         if fn then
            local wrapped = function(self, ...)
               return fn(self.id, ...)
            end
            rawset(self, key, wrapped)
            return wrapped
         end
      end,
   })
   return {
      __name = "nvim." .. prefix,
      __call = function(_, n)
         if not n or n == 0 then
            n = api["nvim_get_current_" .. prefix]()
         end
         if not cache[n] then
            cache[n] = setmetatable({ id = n }, { __index = t })
         end
         return cache[n]
      end,
      __index = index,
      __eq = function(self, other)
         if not (type(self) == "table") or not (type(other) == "table") then
            return false
         end
         local selfMt = getmetatable(self)
         local otherMt = getmetatable(other)
         if not selfMt or not otherMt then
            return false
         end
         return (selfMt.__index == otherMt.__index) and
         ((self).id == (other).id)
      end,
   }
end
local function genSetMetatable(t, prefix)
   setmetatable(t, genMetatable(t, prefix))
end
genSetMetatable(auto.Buffer, "buf")
genSetMetatable(auto.Window, "win")
genSetMetatable(auto.Tab, "tab")

setmetatable(auto.api, {
   __index = function(self, key)
      local api = vim.api
      local fn = api["nvim_" .. unCamel(key)]
      if fn then
         rawset(self, key, fn)
         return fn
      end
   end,
})

local Augroup = {}






local augroupMt = {
   __index = Augroup,
   __name = "nvim.Augroup",
}

local nvim = {
   api = auto.api,
   Window = auto.Window,
   Buffer = auto.Buffer,
   Tab = auto.Tab,

   UI = UI,
   CommandArgs = auto.CommandArgs,
   CommandAttributes = auto.CommandAttributes,

   scheduleWrap = (vim.schedule_wrap),

   _exports = {},
}

function nvim.createAugroup(name, opts)
   return setmetatable(
   {
      id = nvim.api.createAugroup(name, opts or {}),
      name = name,
   },
   augroupMt)

end

function Augroup:add(event, opts)
   assert(not opts.group)
   local old = opts.group
   opts.group = self.name
   local result = nvim.api.createAutocmd(event, opts)
   opts.group = old
   return result
end

function nvim.ui(n)
   return (a.nvim_list_uis())[n or 1]
end

function nvim.openWin(b, enter, c)
   return nvim.Window(a.nvim_open_win(b and b.id or 0, enter, c))
end

function nvim.createBuf(listed, scratch)
   return nvim.Buffer(a.nvim_create_buf(listed, scratch))
end

function nvim.winBuf(n)
   local win = nvim.Window(n)
   return win, nvim.Buffer(win:getBuf())
end

function nvim.command(fmt, ...)
   a.nvim_command(string.format(fmt, ...))
end

nvim.Buffer.setKeymap = function(self, mode, lhs, rhs, opts)
   opts = opts or {}
   vim.keymap.set(mode, lhs, rhs, {
      nowait = opts.nowait,
      silent = opts.silent,
      script = opts.script,
      expr = opts.expr,
      unique = opts.unique,
      desc = opts.desc,
      callback = opts.callback,
      buffer = self.id,
      replace_keycodes = opts.replace_keycodes,
      remap = opts.remap,
   })
end

nvim.Buffer.delKeymap = function(self, mode, lhs, _opts)
   pcall(vim.keymap.del, mode, lhs, {
      buffer = self.id,
   })
end

return nvim