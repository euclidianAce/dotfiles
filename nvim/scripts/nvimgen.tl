
local fh = assert(io.open(os.getenv"DOTFILE_DIR" .. "/nvim/teal/euclidian/lib/nvim/_autogenerated.tl", "w"))
local function write(...: string)
	fh:write(...)
	fh:write("\n")
end

local record Func
	method: boolean
	name: string
	parameters: {{string}}
	return_type: string
	since: integer
	deprecated_since: integer
end
local record Type
	id: integer
	prefix: string
end
local record Info
	error_types: {string:{string:integer}}
	functions: {Func}
	types: {string:Type}
	ui_options: {string}
	record Version
		api_compatible: integer
		api_level: integer
		api_prerelease: boolean
		major: integer
		minor: integer
		patch: integer
	end
	version: Version
end

local	record OptInfo
	name: string
	shortname: string
	type: string
	global_local: boolean
	commalist: boolean
	scope: string
end

local api_info = vim.fn.api_info() as Info

local pre <const> = [[
local record CommandArgs
	args: string
	bang: boolean
	line1: integer
	line2: integer
	range: integer
	count: integer
	reg: string
	mods: string
end

local record CommandAttributes
	desc: string
	bang: boolean
	bar: boolean
	register: boolean
	buffer: boolean

	enum ArgumentOpt
		"*" "?" "+"
	end
	nargs: integer | ArgumentOpt

	range: string | integer | boolean
	count: integer | boolean

	enum AddrOpt
		"lines" "arguments" "buffers"
		"loaded_buffers" "windows" "tabs"
		"quickfix" "other"
	end

	addr: AddrOpt

	enum CompleteOpt
		"arglist" "augroup" "buffer" "behave"
		"color" "command" "compiler" "cscope"
		"dir" "environment" "event" "expression"
		"file" "file_in_path" "filetype" "function"
		"help" "highlight" "history" "locale"
		"mapclear" "mapping" "menu" "messages"
		"option" "packadd" "shellcmd" "sign"
		"syntax" "syntime" "tag" "tag_listfiles"
		"user" "var" "lua"
	end

	type CompleteListFunc = function(string, string, integer): {string}
	complete: CompleteOpt | CompleteListFunc
end
]]

local typeMap <const>: {string:string} = setmetatable({
	["String"] = "string",
	["Number"] = "number",
	["Float"] = "number",
	["Integer"] = "integer",
	["Boolean"] = "boolean",
	["Buffer"] = "integer",
	["Window"] = "integer",
	["Tabpage"] = "integer",
	["Dictionary"] = "{string:any}",
	["Array"] = "{any}",
}, {
	__index = function(): string
		return "any"
	end
})

local function getTypeName(name: string): string
	local tname: string
	if name:match("ArrayOf") then
		local arrayType = name:gsub("ArrayOf%((.*)%)", "%1")
		if arrayType:find(",") then
			local elementName, _size = arrayType:match("(%S+)%s*,%s*(%d+)")
			local size = tonumber(_size) as integer
			elementName = typeMap[elementName]

			local tupleStr = {}
			for _ = 1, size do
				table.insert(tupleStr, elementName)
			end
			tname = "{" .. table.concat(tupleStr, ",") .. "}"
		else
			tname = "{" .. typeMap[arrayType] .. "}"
		end
	else
		tname = typeMap[name]
	end
	return tname -- .. "--[[" .. name .. "]]"
end

local ins <const> = table.insert

local enum NamespaceName
	"Buffer"
	"Window"
	"Tab"
	"Nvim"
end

local record Namespace
	entries: {string}
	exclude: {string:boolean}
end

local namespaces: {NamespaceName:Namespace} = {
	["Buffer"] = {
		exclude = {
			getOption = true,
			setOption = true,
			call = true,
			setKeymap = true,
			delKeymap = true,
			createUserCommand = true,
		},
		entries = {
			"call: function<Rets...>(Buffer, function(): Rets): Rets",

			"getOption: function(Buffer, StringOpt): string",
			"getOption: function(Buffer, BooleanOpt): boolean",
			"getOption: function(Buffer, IntegerOpt): integer",
			"getOption: function(Buffer, string): number | boolean | string",

			"setOption: function(Buffer, StringOpt, string)",
			"setOption: function(Buffer, BooleanOpt, boolean)",
			"setOption: function(Buffer, IntegerOpt, integer)",
			"setOption: function(Buffer, string, integer | boolean | string)",

			"setKeymap: function(Buffer, vim.Mode | {vim.Mode}, string, string | function, vim.keymap.SetOptions)",
			"delKeymap: function(Buffer, vim.Mode | {vim.Mode}, string, vim.keymap.DelOptions)",

			"createUserCommand: function(Buffer, string, string | function(CommandArgs), CommandAttributes)",
		},
	},
	["Window"] = {
		exclude = {
			getOption = true,
			setOption = true,
			setConfig = true,
			getConfig = true,
		},
		entries = {
			[[record Config
		enum Anchor
			"NW" "NE" "SW" "SE"
		end
		enum Style
			"minimal"
		end
		enum Relativity
			"editor" "win" "cursor"
		end
		enum PredefinedBorder
			"none"
			"single"
			"double"
			"rounded"
			"solid"
			"shadow"
		end
		type Border = PredefinedBorder | { string | { string, string } }

		win: Id
		relative: Relativity
		anchor: Anchor
		row: integer
		col: integer
		width: integer
		height: integer
		zindex: integer
		bufpos: integer
		focusable: boolean
		external: boolean
		style: Style
		border: Border
	end]],
			"getConfig: function(Window): Config",
			"setConfig: function(Window, Config)",

			"getOption: function(Window, StringOpt): string",
			"getOption: function(Window, BooleanOpt): boolean",
			"getOption: function(Window, IntegerOpt): integer",
			"getOption: function(Window, string): integer | boolean | string",

			"setOption: function(Window, StringOpt, string)",
			"setOption: function(Window, BooleanOpt, boolean)",
			"setOption: function(Window, IntegerOpt, integer)",
			"setOption: function(Window, string, integer | boolean | string)",
		},
	},
	["Tab"] = {
		exclude = {},
		entries = {},
	},
	["Nvim"] = {
		exclude = {
			createUserCommand = true,
			createAutocmd = true,
			createAugroup = true,
			doAutocmd = true,
		},
		entries = {
			"createUserCommand: function(string, string | function(CommandArgs), CommandAttributes)",

			[[record AutocmdOpts
		callback: string | function(string)
		command: string
		pattern: string | {string}
		buffer: integer
		group: string
		once: boolean
		nested: boolean
		desc: string
	end]],
			"createAutocmd: function(string | {string}, AutocmdOpts): integer",
			[[record AugroupOpts
		clear: boolean
	end]],
			"createAugroup: function(string, AugroupOpts): integer",
			[[record DoAutocmdOpts
		buffer: integer
		pattern: string | {string}
		group: string
		modeline: boolean
	end]],
			"doAutocmd: function(string | {string}, DoAutocmdOpts)",
		},
	},
}

local function camelCase(s: string): string
	return (s:gsub("%_(%w)", string.upper))
end

local function processDef(f: Func)
	if f.deprecated_since then return end
	local namespace: NamespaceName = "Nvim"
	local name: string
	if f.name:match("^nvim_buf_") then
		namespace = "Buffer"
		name = f.name:sub(10, -1)
	elseif f.name:match("^nvim_win_") then
		namespace = "Window"
		name = f.name:sub(10, -1)
	elseif f.name:match("^nvim_tabpage_") then
		namespace = "Tab"
		name = f.name:sub(14, -1)
	else
		name = f.name:sub(6, -1)
	end
	name = camelCase(name)
	local ns <const> = namespaces[namespace]
	if not ns.exclude[name] then
		local args <const>: {string} = {}
		for _, param in ipairs(f.parameters) do
			ins(args, getTypeName(param[1]))
		end
		if namespace ~= "Nvim" then
			args[1] = namespace
		end
		local ret <const> = f.return_type and f.return_type ~= "void"
			and getTypeName(f.return_type)
			or nil

		ins(ns.entries, name .. ": function(" .. table.concat(args, ", ") .. ")" .. (ret and ": " .. ret or ""))
	end
end

for _, f in ipairs(api_info.functions) do
	processDef(f)
end

local opts = vim.api.nvim_get_all_options_info() as {string:OptInfo}
opts[""] = nil

local wo: {string:{string}} = {
	["string"] = {},
	["boolean"] = {},
	["integer"] = {},
}

local bo: {string:{string}} = {
	["string"] = {},
	["boolean"] = {},
	["integer"] = {},
}

for _, opt in pairs(opts) do
	local tab: {string:{string}}
	if opt.scope == "win" then
		tab = wo
	elseif opt.scope == "buf" then
		tab = bo
	end
	if opt.type == "number" then opt.type = "integer" end
	if tab then
		table.insert(tab[opt.type], opt.name)
	end
end

local function addOpts(ns: Namespace, o: {string:{string}})
	local ordered <const> = {}
	for t, vals in pairs(o) do
		table.insert(ordered, {t, vals})
	end
	table.sort(ordered, function(a: {string, {string}}, b: {string, {string}}): boolean
		return a[1] < b[1]
	end)
	for _, v in ipairs(ordered) do
		local t <const>, vals <const> = v[1], v[2]
		local out <const> = {}
		for _, entry in ipairs(vals) do
			ins(out, string.format("\t%q", entry))
		end
		table.sort(out)
		ins(out, "end")
		ins(out, 1, "enum " .. t:sub(1, 1):upper() .. t:sub(2) .. "Opt")
		table.insert(ns.entries, table.concat(out, "\n\t"))
	end
end
addOpts(namespaces["Window"], wo)
addOpts(namespaces["Buffer"], bo)

local function processNs(ns: NamespaceName)
	write("local record " .. ns)
	write("\ttype Id = integer")
	write("\tid: Id")
	for _, func in ipairs(namespaces[ns].entries) do
		write("\t", func)
	end
	write(("\tmetamethod __call: function(%s, integer): %s"):format(ns, ns))
	write("\tmetamethod __eq: function(any, any): boolean")
	write("end")
end

write(pre)
processNs("Buffer")
processNs("Window")
processNs("Tab")
write("local record api")
for _, func in ipairs(namespaces["Nvim"].entries) do
	write("\t", func)
end
write("end")

write[[
return {
	api = api,
	Buffer = Buffer,
	Window = Window,
	Tab = Tab,
	CommandArgs = CommandArgs,
	CommandAttributes = CommandAttributes,
}]]

fh:close()
