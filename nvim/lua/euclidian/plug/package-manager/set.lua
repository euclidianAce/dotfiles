local ims = require("euclidian.lib.imserialize")
local tree = require("euclidian.plug.package-manager.tree")
local packagespec = require("euclidian.plug.package-manager.packagespec")
local tu = require("euclidian.lib.textutils")
local uv = vim.loop

local Spec = packagespec.Spec

local set = {
   loaded = {},
   getWorld = nil,
}

local tiFmt = tu.insertFormatted

local function generateDef(out, p)
   assert(p.id, "Attempt to generate package def without id")

   tiFmt(out, "Package ")
   local key, s, i = ims.key, ims.string, ims.integer
   ims.begin(out, { newlines = true, indent = "   " })

   ims.beginTable()
   key("kind"); s(p.kind)
   key("id"); i(p.id)

   if p.alias then
      key("alias"); s(p.alias)
   end
   if p.kind == "git" then
      key("repo"); s(p.repo)
      if p.branch then
         key("branch"); s(p.branch)
      end
   elseif p.kind == "local" then
      key("path"); s(p.path)
   end

   if p.dependents then
      local d = {}
      for _, dep in ipairs(p.dependents) do
         if type(dep) == "table" and dep.id then
            table.insert(d, dep.id)
         end
      end

      if #d > 0 then
         key("dependents"); ims.array(d)
      end
   end

   ims.endTable()
   ims.finish()

   table.insert(out, "\n")
end

function set.serialize(ps)
   local out = {
      "-- This file is autogenerated and should not be edited by hand\n",
      "-- unless you know what you are doing :D\n\n",
   }

   local lastId = 0
   local function nextId()
      lastId = lastId + 1
      return lastId
   end

   local function gen(p)
      if not p.id then
         p.id = nextId()
         generateDef(out, p)
      end
   end

   for _, p in ipairs(ps) do
      for _, dep in ipairs(p.dependents or {}) do
         gen(dep)
      end
      gen(p)
   end

   table.insert(out, "\n-- vim: ft=lua")

   for _, p in ipairs(ps) do
      p.id = nil
   end

   return table.concat(out)
end

function set.deserialize(str)
   local packages = {}

   local largestId = -1
   local function Package(p)
      assert(p.id, "Package has no id!")
      packages[p.id] = packagespec.new(p)
      if p.id > largestId then
         largestId = p.id
      end
   end

   local chunk = assert(loadstring(str))
   setfenv(chunk, { Package = Package })
   local ok, err = pcall(chunk)
   if not ok then
      return nil, err
   end

   for _, pkg in pairs(packages) do
      pkg.id = nil
      if pkg.dependents then
         for i, depId in ipairs(pkg.dependents) do
            pkg.dependents[i] = packages[depId]
         end
      end
   end


   for i = largestId, 1, -1 do
      if packages[i] == nil then
         table.remove(packages, i)
      end
   end

   return packages
end



local function loadSet(name)
   local fh, err = io.open(tree.set .. "/" .. name, "r")
   if not fh then
      return nil, err
   end
   local content = fh:read("*a")
   fh:close()
   return set.deserialize(content)
end

local function append(dest, src)
   local i = #dest
   for j, v in ipairs(src) do
      dest[i + j] = v
   end
end

function set.load(name)
   if name == "@World" then
      return set.getWorld()
   else
      if not set.loaded[name] then
         local s, err = loadSet(name)
         if not s then
            return nil, err
         end
         set.loaded[name] = s
      end
      return set.loaded[name]
   end
end

function set.save(name, s)
   assert(name, "Can't save a set without a name")
   assert(s, "No set to save")

   if name:sub(1, 1) == "@" then
      return false, "Set names that begin with '@' are reserved"
   end

   local fh, err = io.open(tree.set .. "/" .. name, "w")
   if not fh then
      return false, err
   end
   fh:write(set.serialize(s), "\n")
   fh:close()
   set.loaded[name] = nil
   return true
end

function set.list()
   local list = {}
   local scanner = uv.fs_scandir(tree.set)
   if scanner then
      for name in uv.fs_scandir_next, scanner do
         if name:sub(1, 1) ~= "." then
            table.insert(list, name)
         end
      end
   end
   return list
end

function set.getWorld()
   local all_names = set.list()
   local all_specs = {}

   for _, name in ipairs(all_names) do
      local loaded, err = set.load(name)
      if not loaded then
         return nil, err
      end
      append(all_specs, loaded)
   end

   return all_specs
end

return set