local a <const> = vim.api

local function failsafe<Args..., Rets...>(f: (function(Args): Rets), err_prefix: string): function(Args): Rets
	local ok = true
	local err: string
	local unpack_ <const> = unpack as function(any): Rets
	return function(...: Args): Rets
		if ok then
			local res <const> = { pcall(f, ...) }
			ok = table.remove(res, 1) as boolean
			if ok then
				return unpack_(res)
			end
			err = res[1] as string
		end
		a.nvim_err_writeln((err_prefix or "") .. err)
	end
end

local function pcallWrap<Args..., Rets...>(f: (function(Args): Rets), err_prefix: string): function(Args): Rets
	local unpack_ <const> = unpack as function(any): Rets
	return function(...: Args): Rets
		local res <const> = { pcall(f, ...) }
		local ok <const> = table.remove(res, 1) as boolean
		if ok then
			return unpack_(res)
		end
		local err <const> = res[1] as string
		a.nvim_err_writeln((err_prefix or "") .. err)
	end
end

local record UI
	chan: integer
	height: integer
	width: integer
	rgb: boolean
	ext_cmdline: boolean
	ext_hlstate: boolean
	ext_linegrid: boolean
	ext_messages: boolean
	ext_multigrid: boolean
	ext_popupmenu: boolean
	ext_tabline: boolean
	ext_termcolors: boolean
	ext_wildmenu: boolean
end

local auto <const> = require("euclidian.lib.nvim._autogenerated")

local function unCamel(s: string): string
	return (s:gsub("[A-Z]", function(m: string): string
		return "_" .. m:lower()
	end))
end
local function genMetatable<T>(t: T, prefix: string): metatable<T>
	local cache <const>: {integer:T} = setmetatable({}, { __mode = "kv" })
	local api <const> = vim.api as {string:function}
	local index <const> = setmetatable({}, {
		__index = function(self: {string:function}, key: string): function
			local fn <const> = api["nvim_" .. prefix .. "_" .. unCamel(key)]
			if fn then
				local wrapped <const> = function(self: {string:integer}, ...: any): any
					return fn(self.id, ...)
				end
				rawset(self, key, wrapped)
				return wrapped
			end
		end
	})
	return {
		__name = "nvim." .. prefix,
		__call = function(_: T, n: integer): T
			if not n or n == 0 then
				n = api["nvim_get_current_" .. prefix]() as integer
			end
			if not cache[n] then
				cache[n] = setmetatable({ id = n } as T, { __index = t })
			end
			return cache[n]
		end,
		__index = index,
		__eq = function(self: any, other: any): boolean
			if not (self is table) or not (other is table) then
				return false
			end
			local selfMt = getmetatable(self)
			local otherMt = getmetatable(other)
			if not selfMt or not otherMt then
				return false
			end
			return (selfMt.__index == otherMt.__index)
				and ((self as table).id == (other as table).id)
		end,
	}
end
local function genSetMetatable<T>(t: T, prefix: string)
	setmetatable(t, genMetatable(t, prefix))
end
genSetMetatable(auto.Buffer, "buf")
genSetMetatable(auto.Window, "win")
genSetMetatable(auto.Tab, "tab")

setmetatable(auto.api, {
	__index = function(self: {string:any}, key: string): any
		local api <const> = vim.api as {string:function}
			local fn <const> = api["nvim_" .. unCamel(key)]
			if fn then
				rawset(self, key, fn)
				return fn
			end
	end
})

local record CommandOpts
	name: string
	body: string | function

	enum ArgumentOpt
		"*" "?" "+"
	end
	nargs: integer | ArgumentOpt

	enum CompleteOpt
		"arglist" "augroup" "buffer" "behave"
		"color" "command" "compiler" "cscope"
		"dir" "environment" "event" "expression"
		"file" "file_in_path" "filetype" "function"
		"help" "highlight" "history" "locale"
		"mapclear" "mapping" "menu" "messages"
		"option" "packadd" "shellcmd" "sign"
		"syntax" "syntime" "tag" "tag_listfiles"
		"user" "var" "lua"
	end
	type CompleteFunc = function(string, string, integer): string
	type CompleteListFunc = function(string, string, integer): {string}
	complete: CompleteOpt | CompleteFunc
	completelist: CompleteListFunc

	range: string | integer | boolean
	count: integer | boolean

	enum AddrOpt
		"lines" "arguments" "buffers"
		"loaded_buffers" "windows" "tabs"
		"quickfix" "other"
	end
	addr: AddrOpt

	bang: boolean
	bar: boolean
	register: boolean
	buffer: boolean

	overwrite: boolean
end

local record AutocmdOpts
	buffer: boolean | integer
	once: boolean
	nested: boolean
	canError: boolean
end

local nvim <const> = {
	api = auto.api,
	Window = auto.Window,
	Buffer = auto.Buffer,
	Tab = auto.Tab,

	UI = UI,
	MapOpts = auto.MapOpts,
	CommandArgs = auto.CommandArgs,
	CommandAttributes = auto.CommandAttributes,

	CommandOpts = CommandOpts,
	AutocmdOpts = AutocmdOpts,

	_exports: {string:function} = {},
}

function nvim.ui(n: integer): UI
	return (a.nvim_list_uis() as {UI})[n or 1]
end

function nvim.openWin(b: nvim.Buffer, enter: boolean, c: nvim.Window.Config): nvim.Window
	return nvim.Window(a.nvim_open_win(b and b.id or 0, enter, c))
end

function nvim.createBuf(listed: boolean, scratch: boolean): nvim.Buffer
	return nvim.Buffer(a.nvim_create_buf(listed, scratch))
end

function nvim.winBuf(n: integer): nvim.Window, nvim.Buffer
	local win <const> = nvim.Window(n)
	return win, nvim.Buffer(win:getBuf())
end

function nvim.command(fmt: string, ...: any)
	a.nvim_command(string.format(fmt, ...))
end

local function toStrArr(s: string | {string}): {string}
	if s is string then
		return {s}
	else
		return s
	end
end

function nvim.autocmd(sEvents: string | {string}, sPatts: string | {string}, expr: string | function, maybeOpts: AutocmdOpts)
	assert(sEvents, "no events")
	assert(expr, "no expr")

	local events <const> = table.concat(toStrArr(sEvents), ",")
	local opts <const> = maybeOpts or {}

	assert(sPatts as boolean or opts.buffer as boolean, "no patterns or buffer")
	local patts <const> = sPatts and table.concat(toStrArr(sPatts), ",")

	local actualExpr: string
	if expr is string then
		actualExpr = expr
	else
		local key <const> = "autocmd" .. events .. (patts or "buffer=" .. tostring(opts.buffer))
		if opts.canError then
			nvim._exports[key] = pcallWrap(expr, ("Error in autocmd for %s %s: "):format(events, patts))
		else
			nvim._exports[key] = failsafe(expr, ("Error in autocmd for %s %s: "):format(events, patts))
		end
		actualExpr = ("lua require'euclidian.lib.nvim'._exports[%q]()"):format(key)
	end
	local cmd = { "autocmd" }
	table.insert(cmd, events)
	if opts.buffer then
		table.insert(cmd, ("<buffer=%d>"):format(opts.buffer == true and vim.api.nvim_get_current_buf() or opts.buffer as integer))
	end
	if patts then table.insert(cmd, patts) end
	if opts.once then table.insert(cmd, "++once") end
	if opts.nested then table.insert(cmd, "++nested") end
	table.insert(cmd, actualExpr)

	nvim.command(table.concat(cmd, " "))
end

function nvim.augroup(name: string, lst: {{string | {string}, string | {string}, string | function, AutocmdOpts}}, clear: boolean)
	nvim.command("augroup %s", name)
	if clear then
		nvim.command("autocmd!")
	end
	for _, v in ipairs(lst) do
		nvim.autocmd(v[1], v[2], v[3], v[4])
	end
	nvim.command("augroup END")
end

local function copyMapOpts(opts: nvim.MapOpts): nvim.MapOpts
	return {
		nowait: boolean = opts.nowait,
		silent: boolean = opts.silent,
		script: boolean = opts.script,
		expr: boolean = opts.expr,
		unique: boolean = opts.unique,
		noremap: boolean = opts.noremap,
		desc: string = opts.desc,
		callback: function = opts.callback,
	}
end

local function keymapArgs(rhs: string | function, userSettings: nvim.MapOpts): string, nvim.MapOpts
	if rhs is string then
		return rhs, userSettings
	else
		local copy <const> = copyMapOpts(userSettings)
		copy.callback = rhs
		return '', copy
	end
end

function nvim.setKeymap(mode: vim.Mode, lhs: string, rhs: string | function, userSettings: nvim.MapOpts)
	a.nvim_set_keymap(mode, lhs, keymapArgs(rhs, userSettings))
end

function nvim.delKeymap(mode: vim.Mode, lhs: string)
	pcall(a.nvim_del_keymap, mode, lhs)
end

nvim.Buffer.setKeymap = function(self: nvim.Buffer, mode: vim.Mode, lhs: string, rhs: string | function, userSettings: nvim.MapOpts)
	a.nvim_buf_set_keymap(self.id, mode, lhs, keymapArgs(rhs, userSettings))
end

nvim.Buffer.delKeymap = function(self: nvim.Buffer, mode: vim.Mode, lhs: string)
	pcall(a.nvim_buf_del_keymap, self.id, mode, lhs)
end

return nvim
