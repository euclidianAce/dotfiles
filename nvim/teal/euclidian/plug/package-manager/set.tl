local ims <const> = require("euclidian.lib.imserialize")
local tree <const> = require("euclidian.plug.package-manager.tree")
local packagespec <const> = require("euclidian.plug.package-manager.packagespec")
local tu <const> = require("euclidian.lib.textutils")
local uv <const> = vim.loop

local type Spec = packagespec.Spec

local set <const> = {
	loaded: {string:{Spec}} = {},
	getWorld: function(): {Spec}, string = nil
}

local tiFmt <const> = tu.insertFormatted

local function generateDef(out: {string}, p: Spec)
	assert(p.id, "Attempt to generate package def without id")

	tiFmt(out, "Package ")
	local key <const>, s <const>, i <const> = ims.key, ims.string, ims.integer
	ims.begin(out, { newlines = true, indent = "   " })

	ims.beginTable()
	key("kind") s(p.kind)
	key("id") i(p.id)

	if p.alias then
		key "alias" s(p.alias)
	end
	if p.kind == "git" then
		key "repo" s(p.repo)
		if p.branch then
			key "branch" s(p.branch)
		end
	elseif p.kind == "local" then
		key "path" s(p.path)
	end

	if p.dependents then
		local d <const> = {}
		for _, dep in ipairs(p.dependents) do
			if dep is Spec and dep.id then
				table.insert(d, dep.id)
			end
		end

		if #d > 0 then
			key "dependents" ims.array(d)
		end
	end

	ims.endTable()
	ims.finish()

	table.insert(out, "\n")
end

function set.serialize(ps: {Spec}): string
	local out <const> = {
		"-- This file is autogenerated and should not be edited by hand\n",
		"-- unless you know what you are doing :D\n\n",
	}

	local lastId = 0
	local function nextId(): integer
		lastId = lastId + 1
		return lastId
	end

	local function gen(p: Spec)
		if not p.id then
			p.id = nextId()
			generateDef(out, p)
		end
	end

	for _, p in ipairs(ps) do
		for _, dep in ipairs(p.dependents or {}) do
			gen(dep as Spec)
		end
		gen(p)
	end

	table.insert(out, "\n-- vim: ft=lua")

	for _, p in ipairs(ps) do
		p.id = nil
	end

	return table.concat(out)
end

function set.deserialize(str: string): {Spec}, string
	local packages <const>: {integer:Spec} = {}

	local largestId = -1
	local function Package(p: Spec)
		assert(p.id, "Package has no id!")
		packages[p.id] = packagespec.new(p)
		if p.id > largestId then
			largestId = p.id
		end
	end

	local chunk <const> = assert(loadstring(str))
	setfenv(chunk, { Package = Package } as table)
	local ok <const>, err <const> = pcall(chunk)
	if not ok then
		return nil, err as string
	end

	for _, pkg in pairs(packages) do
		pkg.id = nil
		if pkg.dependents then
			for i, depId in ipairs(pkg.dependents) do
				pkg.dependents[i] = packages[depId as integer]
			end
		end
	end

	-- Guarantee that packages has no holes
	for i = largestId, 1, -1 do
		if packages[i] == nil then
			table.remove(packages, i)
		end
	end

	return packages
end

-- TODO: use luv to do the file reads/writes

local function loadSet(name: string): {Spec}, string
	local fh <const>, err <const> = io.open(tree.set .. "/" .. name, "r")
	if not fh then
		return nil, err
	end
	local content <const> = fh:read("*a")
	fh:close()
	return set.deserialize(content)
end

local function append<T>(dest: {T}, src: {T})
	local i = #dest
	for j, v in ipairs(src) do
		dest[i+j] = v
	end
end

function set.load(name: string): {Spec}, string
	if name == "@World" then
		return set.getWorld()
	else
		if not set.loaded[name] then
			local s <const>, err <const> = loadSet(name)
			if not s then
				return nil, err
			end
			set.loaded[name] = s
		end
		return set.loaded[name]
	end
end

function set.save(name: string, s: {Spec}): boolean, string
	assert(name, "Can't save a set without a name")
	assert(s, "No set to save")

	if name:sub(1, 1) == "@" then
		return false, "Set names that begin with '@' are reserved"
	end

	local fh <const>, err <const> = io.open(tree.set .. "/" .. name, "w")
	if not fh then
		return false, err
	end
	fh:write(set.serialize(s), "\n")
	fh:close()
	set.loaded[name] = nil
	return true
end

function set.list(): {string}
	local list <const> = {}
	local scanner <const> = uv.fs_scandir(tree.set)
	if scanner then
		for name in uv.fs_scandir_next, scanner do
			if name:sub(1, 1) ~= "." then
				table.insert(list, name)
			end
		end
	end
	return list
end

function set.getWorld(): {Spec}, string
	local all_names <const> = set.list()
	local all_specs <const>: {Spec} = {}

	for _, name in ipairs(all_names) do
		local loaded <const>, err <const> = set.load(name)
		if not loaded then
			return nil, err
		end
		append(all_specs, loaded)
	end

	return all_specs
end

return set
