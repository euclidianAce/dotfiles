local a <const> = vim.api

local record UI
	chan: integer
	height: integer
	width: integer
	rgb: boolean
	ext_cmdline: boolean
	ext_hlstate: boolean
	ext_linegrid: boolean
	ext_messages: boolean
	ext_multigrid: boolean
	ext_popupmenu: boolean
	ext_tabline: boolean
	ext_termcolors: boolean
	ext_wildmenu: boolean
end

local auto <const> = require("euclidian.lib.nvim._autogenerated")

local function unCamel(s: string): string
	return (s:gsub("[A-Z]", function(m: string): string
		return "_" .. m:lower()
	end))
end
local function genMetatable<T>(t: T, prefix: string): metatable<T>
	local cache <const>: {integer:T} = setmetatable({}, { __mode = "kv" })
	local api <const> = vim.api as {string:function}
	local index <const> = setmetatable({}, {
		__index = function(self: {string:function}, key: string): function
			local fn <const> = api["nvim_" .. prefix .. "_" .. unCamel(key)]
			if fn then
				local wrapped <const> = function(self: {string:integer}, ...: any): any
					return fn(self.id, ...)
				end
				rawset(self, key, wrapped)
				return wrapped
			end
		end
	})
	return {
		__name = "nvim." .. prefix,
		__call = function(_: T, n: integer): T
			if not n or n == 0 then
				n = api["nvim_get_current_" .. prefix]() as integer
			end
			if not cache[n] then
				cache[n] = setmetatable({ id = n } as T, { __index = t })
			end
			return cache[n]
		end,
		__index = index,
		__eq = function(self: any, other: any): boolean
			if not (self is table) or not (other is table) then
				return false
			end
			local selfMt = getmetatable(self)
			local otherMt = getmetatable(other)
			if not selfMt or not otherMt then
				return false
			end
			return (selfMt.__index == otherMt.__index)
				and ((self as table).id == (other as table).id)
		end,
	}
end
local function genSetMetatable<T>(t: T, prefix: string)
	setmetatable(t, genMetatable(t, prefix))
end
genSetMetatable(auto.Buffer, "buf")
genSetMetatable(auto.Window, "win")
genSetMetatable(auto.Tab, "tab")

setmetatable(auto.api, {
	__index = function(self: {string:any}, key: string): any
		local api <const> = vim.api as {string:function}
		local fn <const> = api["nvim_" .. unCamel(key)]
		if fn then
			rawset(self, key, fn)
			return fn
		end
	end
})

local record Augroup
	type Id = integer

	id: Id
	name: string
end

local augroupMt <const>: metatable<Augroup> = {
	__index = Augroup,
	__name = "nvim.Augroup",
}

local nvim <const> = {
	api = auto.api,
	Window = auto.Window,
	Buffer = auto.Buffer,
	Tab = auto.Tab,

	UI = UI,
	CommandArgs = auto.CommandArgs,
	CommandAttributes = auto.CommandAttributes,

	scheduleWrap = (vim.schedule_wrap as function<Ret...>(function(Ret)): function(Ret)),

	_exports: {string:function} = {},
}

function nvim.createAugroup(name: string, opts: nvim.api.AugroupOpts): Augroup
	return setmetatable(
		{
			id = nvim.api.createAugroup(name, opts or {}),
			name = name,
		} as Augroup,
		augroupMt
	)
end

function Augroup:add(event: string | {string}, opts: nvim.api.AutocmdOpts): integer
	assert(not opts.group)
	local old <const> = opts.group
	opts.group = self.name
	local result <const> = nvim.api.createAutocmd(event, opts)
	opts.group = old
	return result
end

function nvim.ui(n: integer): UI
	return (a.nvim_list_uis() as {UI})[n or 1]
end

function nvim.openWin(b: nvim.Buffer, enter: boolean, c: nvim.Window.Config): nvim.Window
	return nvim.Window(a.nvim_open_win(b and b.id or 0, enter, c))
end

function nvim.createBuf(listed: boolean, scratch: boolean): nvim.Buffer
	return nvim.Buffer(a.nvim_create_buf(listed, scratch))
end

function nvim.winBuf(n: integer): nvim.Window, nvim.Buffer
	local win <const> = nvim.Window(n)
	return win, nvim.Buffer(win:getBuf())
end

function nvim.command(fmt: string, ...: any)
	a.nvim_command(string.format(fmt, ...))
end

nvim.Buffer.setKeymap = function(self: nvim.Buffer, mode: vim.Mode | {vim.Mode}, lhs: string, rhs: string | function, opts: vim.keymap.SetOptions)
	opts = opts or {}
	vim.keymap.set(mode, lhs, rhs, {
		nowait: boolean = opts.nowait,
		silent: boolean = opts.silent,
		script: boolean = opts.script,
		expr: boolean = opts.expr,
		unique: boolean = opts.unique,
		desc: string = opts.desc,
		callback: function = opts.callback,
		buffer: boolean | integer = self.id,
		replace_keycodes: boolean = opts.replace_keycodes,
		remap: boolean = opts.remap,
	})
end

nvim.Buffer.delKeymap = function(self: nvim.Buffer, mode: vim.Mode | {vim.Mode}, lhs: string, _opts: vim.keymap.DelOptions)
	pcall(vim.keymap.del, mode, lhs, {
		buffer: integer | boolean = self.id
	})
end

return nvim
